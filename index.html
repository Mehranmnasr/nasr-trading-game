<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ø¨Ø§Ø²ÛŒ ØªØ±ÛŒØ¯ Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ù†ØµØ±</title>
  <!-- Libraries -->
  <script src="https://unpkg.com/lightweight-charts@4.1.2/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.0.0/dist/chartjs-plugin-annotation.min.js"></script>
  <style>
    body {
      background-color: #003366;
      color: white;
      font-family: sans-serif;
      direction: rtl;
      text-align: center;
      margin: 20px;
    }
    #timeFrameTabs { margin-bottom: 10px; }
    .tab {
      padding: 10px 8px;
      margin: 0 5px;
      border: 1px solid #555;
      cursor: pointer;
      display: inline-block;
      background-color: #1e1e1e;
    }
    .tab.active {
      background-color: #007bff;
      color: white;
      border-color: #007bff;
    }
    .timeframe-tab {
      padding: 5px 4px;
      margin: 0 2.5px;
      border: 1px solid #555;
      cursor: pointer;
      display: inline-block;
      background-color: #1e1e1e;
      font-size: 14px;
    }
    .timeframe-tab.active {
      background-color: #007bff;
      color: white;
      border-color: #007bff;
    }
    .coin-tab {
      padding: 6px 8px;
      margin: 2px 3px;
      font-size: 12px;
      background-color: #1e1e1e;
      border: 1px solid #555;
      display: inline-block;
      width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .coin-tab.active {
      background-color: #0056b3;
      border-color: #0056b3;
    }
    #chartContainer {
      width: 100%;
      max-width: 400px;
      background-color: #0d1b2a;
      aspect-ratio: 1;
      margin: auto;
      border-radius: 8px;
      overflow: hidden;
    }
    #rsiChartContainer {
      width: 300px;
      height: 150px;
      background-color: white;
      margin: 20px auto;
      border-radius: 6px;
    }
    .btn {
      padding: 10px 20px;
      margin: 5px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
    }
    .upgrade-btn {
      padding: 8px 12px;
      margin: 2px 1px;
      font-size: 14px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: white;
    }
    .upgrade-btn:disabled { background-color: #6c757d; cursor: not-allowed; }
    .info { margin-top: 10px; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    select, input {
      padding: 6px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #555;
      background-color: #1e1e1e;
      color: white;
    }
    #freezePriceBtn {
      margin-top: 10px;
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      display: block;
      margin: 10px auto 0;
    }
    #overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 999;
    }
    #walletCard, #upgradeCard, #infoCard, #profileCard, #myCoinForm, #historyCard {
      display: none;
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      color: black;
      padding: 20px;
      border-radius: 8px;
      width: 320px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 1000;
      cursor: pointer;
    }
    #historyCard { width: 360px; max-height: 340px; overflow-y: auto; }
    #walletCard ul { text-align: right; max-height: 200px; overflow-y: auto; padding-right: 20px; }
    #walletCard li { list-style: none; padding: 8px; border-bottom: 1px solid #eee; }
    #walletCard li:last-child { border-bottom: none; }
    #walletTab { background-color: #28a745; }
    #walletTab.active { background-color: #218838; }
    #upgradeCard .upgrade-item {
      display: flex; justify-content: space-between; align-items: center;
      padding: 8px 0; border-bottom: 1px solid #eee;
    }
    #upgradeCard .upgrade-item:last-child { border-bottom: none; }
    #upgradeTab { background-color: #6f42c1; }
    #upgradeTab.active { background-color: #5a32a3; }
    .upgrade-tab-inactive { opacity: 0.5; cursor: not-allowed; }
    /* ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª */
    #historyTab { background-color: #a0522d; border-radius: 5px; }
    #historyTab.active { background-color: #8b4513; }
    #historyCard table { width: 100%; border-collapse: collapse; }
    #historyCard th, #historyCard td {
      border-bottom: 1px solid #ddd; padding: 6px; text-align: center;
      font-size: 13px; color: black;
    }
  </style>
</head>
<body>
  <h1>Ø¨Ø§Ø²ÛŒ ØªØ±ÛŒØ¯ Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ù†ØµØ±</h1>
  <div id="timeFrameTabs">
    <span class="tab" id="infoTab">â•</span>
    <div id="infoCard">
      <h3>Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø±Ø²</h3>
      <p>Ø§Ø³Ù… Ø§Ø±Ø²: <span id="coinNameDisplay">Ø¨ÛŒØªÚ©ÙˆÛŒÙ†</span></p>
      <p>Ù…Ø§Ø±Ú©Øª Ú©Ù¾: <span id="marketCap">336.0B</span></p>
      <p>ØªØ¹Ø¯Ø§Ø¯ Ø¹Ø±Ø¶Ù‡ Ú©Ù„: <span id="totalSupplyDisplay">21.00M</span></p>
      <p id="dominanceDisplay" style="display:none;">Ø¯Ø§Ù…ÛŒÙ†Ù†Ø³ Ø¨ÛŒØªÚ©ÙˆÛŒÙ†: <span id="bitcoinDominanceValue">40%</span></p>
      <p>Ù…ÛŒØ²Ø§Ù† Ø³Ú©Ù‡ Ù‡Ø§ÛŒ Ø§Ø±Ø² Ø¨ØµÙˆØ±Øª Ø¯Ø±ØµØ¯: <span id="percentRemaining">100%</span></p>
      <p>Ù…ÛŒØ²Ø§Ù† Ø³Ú©Ù‡ Ù‡Ø§ÛŒ Ø®Ø±ÛŒØ¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø±Ø² Ø¨ØµÙˆØ±Øª Ø¯Ø±ØµØ¯: <span id="percentBought">0%</span></p>
      <hr style="margin:10px 0;">
      <h4>ØµÙ†Ø¯ÙˆÙ‚ Ù†Ù‚Ø¯ÛŒÙ†Ú¯ÛŒ</h4>
      <p>Ù…ÙˆØ¬ÙˆØ¯ÛŒ ØµÙ†Ø¯ÙˆÙ‚: $<span id="liquidityPoolValue">100000</span></p>
      <div style="margin-top:8px;">
        <button class="btn" onclick="depositToPool(100000)" style="background-color:#28a745; font-size:12px; padding:4px 8px; margin:2px;">+ 100K</button>
        <button class="btn" onclick="depositToPool(1000000)" style="background-color:#28a745; font-size:12px; padding:4px 8px; margin:2px;">+ 1M</button>
        <button class="btn" onclick="depositToPool(10000000)" style="background-color:#28a745; font-size:12px; padding:4px 8px; margin:2px;">+ 10M</button>
      </div>
      <div style="margin-top:6px;">
        <button class="btn" onclick="withdrawFromPool(100000)" style="background-color:#dc3545; font-size:12px; padding:4px 8px; margin:2px;">- 100K</button>
        <button class="btn" onclick="withdrawFromPool(1000000)" style="background-color:#dc3545; font-size:12px; padding:4px 8px; margin:2px;">- 1M</button>
        <button class="btn" onclick="withdrawFromPool(10000000)" style="background-color:#dc3545; font-size:12px; padding:4px 8px; margin:2px;">- 10M</button>
      </div>
      <small>Ø¨Ø±Ø§ÛŒ Ø¨Ø³ØªÙ† Ø¨Ø±Ú¯Ù‡ØŒ Ø±ÙˆÛŒ Ø§ÛŒÙ†Ø¬Ø§ Ú©Ù„ÛŒÚ© Ú©Ù†</small>
    </div>
    <div id="secretForm" style="display:none; margin-top:20px;">
      <input type="text" id="secretCode" placeholder="Ú©Ø¯ Ù…Ø®ÙÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"/>
      <input type="number" id="secretAmount" placeholder="Ù…Ù‚Ø¯Ø§Ø± Ø¯Ù„Ø§Ø±"/>
      <button id="applySecret">ØªØ£ÛŒÛŒØ¯</button>
    </div>
    <span class="tab" id="secretTab">â•</span>
    <span class="tab" id="myCoinTab">ğŸª™</span>
    <div id="myCoinForm">
      <h3>Ø³Ø§Ø®Øª Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø´Ø®ØµÛŒ</h3>
      <p>Ù‡Ø²ÛŒÙ†Ù‡ Ø³Ø§Ø®Øª: <strong>100 Ø¯Ù„Ø§Ø±</strong></p>
      <input type="text" id="coinNameInput" placeholder="Ù†Ø§Ù… Ø§Ø±Ø² (Ù…Ø«Ù„Ø§Ù‹ Ù†ØµØ±â€ŒÚ©ÙˆÛŒÙ†)" style="width:100%; margin:8px 0; padding:6px;">
      <input type="number" id="totalSupplyInput" placeholder="ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ø³Ú©Ù‡â€ŒÙ‡Ø§ (Ù…Ø«Ù„Ø§Ù‹ 1000000)" min="1000" style="width:100%; margin:8px 0; padding:6px;">
      <input type="number" id="listingPriceInput" placeholder="Ù‚ÛŒÙ…Øª Ù„ÛŒØ³Øª Ø´Ø¯Ù† (Ø¯Ù„Ø§Ø±)" min="0.01" step="0.01" style="width:100%; margin:8px 0; padding:6px;">
      <label for="networkSelect">Ø´Ø¨Ú©Ù‡ Ø§Ø±Ø²:</label>
      <select id="networkSelect" style="width:100%; margin:8px 0; padding:6px;">
        <option value="native">Ø¨ÙˆÙ…ÛŒ</option>
        <option value="bitcoin">Ø¨ÛŒØªÚ©ÙˆÛŒÙ†</option>
        <option value="ethereum">Ø§ØªØ±ÛŒÙˆÙ…</option>
        <option value="binance">Ø¨Ø§ÛŒÙ†Ù†Ø³ Ú©ÙˆÛŒÙ†</option>
      </select>
      <div style="margin-top:10px;">
        <button id="createCoinBtn" class="btn" style="background-color:#28a745; color:white; width:100%;">Ø³Ø§Ø®Øª Ø§Ø±Ø² ğŸš€</button>
      </div>
      <small style="display:block; margin-top:10px; cursor:pointer;" id="closeMyCoinForm">Ù„ØºÙˆ</small>
    </div>
    <span class="tab" id="profileTab">ğŸ§‘ğŸ»â€âœˆï¸</span>
    <div id="profileCard">
      <h3>Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø±</h3>
      <p>Ù†Ø§Ù…: <strong id="traderName">Ù¾Ù„ÛŒØ±</strong></p>
      <p>Ø³Ø±Ù…Ø§ÛŒÙ‡ Ø§ÙˆÙ„ÛŒÙ‡: $1,000</p>
      <p>Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ¹Ù„ÛŒ: $<span id="currentBalanceProfile">1000</span></p>
      <p>Ø³ÙˆØ¯/Ø²ÛŒØ§Ù† Ú©Ù„: <span id="totalPnLPercent">0.00%</span></p>
      <p>Ø³Ø·Ø­ Ú©Ø§Ø±Ø¨Ø±ÛŒ: <span id="userLevel">ØªØ§Ø²Ù‡ Ú©Ø§Ø±</span> <span id="userStars">â­</span></p>
      <small>Ø¨Ø±Ø§ÛŒ Ø¨Ø³ØªÙ†ØŒ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯</small>
    </div>
    <span class="tab" id="walletTab">ğŸ’¼</span>
    <div id="walletCard">
      <h3>Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù…Ù†</h3>
      <ul id="walletList"></ul>
      <small>Ø¨Ø±Ø§ÛŒ Ø¨Ø³ØªÙ†ØŒ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯</small>
    </div>
    <span class="tab" id="upgradeTab">ğŸ’</span>
    <div id="upgradeCard">
      <h3>Ø§Ø±ØªÙ‚Ø§ÛŒ Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„</h3>
      <div class="upgrade-item">
        <span>Ø§ÙØ²Ø§ÛŒØ´ Ø³Ø±Ø¹Øª ØªØ±Ø§Ú©Ù†Ø´ (TPS)</span>
        <button class="upgrade-btn" id="upgradeTpsBtn">Ø®Ø±ÛŒØ¯</button>
      </div>
      <div class="upgrade-item">
        <span>Ø¨Ù‡Ø¨ÙˆØ¯ Ø§Ù…Ù†ÛŒØª (RSA512 -> SHA256)</span>
        <button class="upgrade-btn" id="upgradeSecurityBtn">Ø®Ø±ÛŒØ¯</button>
      </div>
      <div class="upgrade-item">
        <span>ØªØºÛŒÛŒØ± Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Ø§Ø¬Ù…Ø§Ø¹ (PoW -> PoS)</span>
        <button class="upgrade-btn" id="upgradeConsensusBtn">Ø®Ø±ÛŒØ¯</button>
      </div>
      <div class="upgrade-item">
        <span>Ù‚Ø§Ø¨Ù„ÛŒØª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± NFT</span>
        <button class="upgrade-btn" id="upgradeNftBtn">Ø®Ø±ÛŒØ¯</button>
      </div>
      <div class="upgrade-item">
        <span>Ù…Ø§Ø±Ú©ØªÛŒÙ†Ú¯ Ùˆ Ø¨Ø±Ù†Ø¯ÛŒÙ†Ú¯</span>
        <button class="upgrade-btn" id="upgradeMarketingBtn">Ø®Ø±ÛŒØ¯</button>
      </div>
      <small>Ø¨Ø±Ø§ÛŒ Ø¨Ø³ØªÙ†ØŒ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯</small>
    </div>
  </div>
  <span class="timeframe-tab active" data-frame="live">30 Ø¯Ù‚ÛŒÙ‚Ù‡</span>
  <span class="timeframe-tab" data-frame="hour1">1 Ø³Ø§Ø¹ØªÙ‡</span>
  <span class="timeframe-tab" data-frame="hour4">4 Ø³Ø§Ø¹ØªÙ‡</span>
  <span class="timeframe-tab" data-frame="day1">Ø±ÙˆØ²Ø§Ù†Ù‡</span>
  <span class="timeframe-tab" data-frame="week1">Ù‡ÙØªÚ¯ÛŒ</span>
  <span class="tab coin-tab" id="coinNameTab">Ø¨ÛŒØªÚ©ÙˆÛŒÙ†</span>
  <span class="tab coin-tab" id="coinEthereumTab">Ø§ØªØ±ÛŒÙˆÙ…</span>
  <span class="tab coin-tab" id="coinBinanceTab">Ø¨Ø§ÛŒÙ†Ù†Ø³ Ú©ÙˆÛŒÙ†</span>
  <span class="tab coin-tab" id="personalCoinTab" style="display:none;"></span>
  <div id="calendarContainer" style="margin-top:20px; background:white; color:black; padding:1px; border-radius:6px; width:100px; font-size:13px; margin:auto;">
    <p>ØªØ§Ø±ÛŒØ® ÙØ¹Ù„ÛŒ: <span id="virtualDayDisplay">1/1/2022</span></p>
  </div>
  <button id="freezePriceBtn" title="ÙØ±ÛŒØ² Ù‚ÛŒÙ…Øª (Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù¾Ø§Ù…Ù¾/Ø¯Ø§Ù…Ù¾)">â¸ï¸</button>
  <div id="chartContainer">
    <div id="priceChart" style="width:100%; height:100%;"></div>
  </div>
  <div id="rsiChartContainer">
    <canvas id="rsiChart"></canvas>
  </div>
  <div id="controlPanel">
    <div class="info">
      <span>Ù…ÙˆØ¬ÙˆØ¯ÛŒ: <span id="balance">1000</span> Ø¯Ù„Ø§Ø±</span>
    </div>
    <div class="info">
      <span>Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ Ø§Ø±Ø²: $<span id="currentPrice">16000</span> (<span id="priceChange24h">+0.00%</span>)</span>
    </div>
    <div class="info">
      <span>Ø­Ø¯ Ø¶Ø±Ø± ÙØ¹Ø§Ù„: $<span id="stopLossDisplay">â€”</span></span>
    </div>
    <div>
      <button class="btn" id="buyBtn" style="background-color:#28a745;">Ø®Ø±ÛŒØ¯ ğŸŸ¢</button>
      <button class="btn" id="sellBtn" style="background-color:#dc3545;">ÙØ±ÙˆØ´ ğŸ”´</button>
    </div>
    <div class="info">
      <label for="tradePercent">Ùª Ù…Ù‚Ø¯Ø§Ø± Ø®Ø±ÛŒØ¯/ÙØ±ÙˆØ´:</label>
      <select id="tradePercent">
        <option value="10">10%</option>
        <option value="20">20%</option>
        <option value="50">50%</option>
        <option value="100">100%</option>
      </select>
    </div>
    <div class="info">
      <label for="orderType">Ù†ÙˆØ¹ Ø§ÙˆØ±Ø¯Ø±:</label>
      <select id="orderType">
        <option value="market">Ù…Ø§Ø±Ú©Øª</option>
        <option value="limit">Ù„ÛŒÙ…ÛŒØª</option>
      </select>
    </div>
    <div class="info" id="limitPriceInput" style="display:none;">
      <label for="limitPrice">Ù‚ÛŒÙ…Øª Ø¯Ù„Ø®ÙˆØ§Ù‡:</label>
      <input type="number" id="limitPrice" placeholder="Ù‚ÛŒÙ…Øª Ø¯Ù„Ø®ÙˆØ§Ù‡ Ø®Ø±ÛŒØ¯/ÙØ±ÙˆØ´" min="0" step="any"/>
    </div>
    <div class="info">
      <label for="stopLossPercent">Ùª Ø­Ø¯ Ø¶Ø±Ø±:</label>
      <select id="stopLossPercent">
        <option value="5">5Ùª</option>
        <option value="10">10Ùª</option>
        <option value="15">15Ùª</option>
      </select>
    </div>
    <div class="info">
      <p>ØªØ¹Ø¯Ø§Ø¯ Ø§Ø±Ø² Ø®Ø±ÛŒØ¯Ø§Ø±ÛŒâ€ŒØ´Ø¯Ù‡: <span id="coinAmount">0</span> Ø¹Ø¯Ø¯</p>
      <p>Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù‚ÛŒÙ…Øª Ø®Ø±ÛŒØ¯Ø§Ø±ÛŒâ€ŒØ´Ø¯Ù‡: $<span id="avgPrice">0</span></p>
      <p>Ø§Ø±Ø²Ø´ Ø¯Ø§Ø±Ø§ÛŒÛŒâ€ŒÙ‡Ø§ÛŒ Ø®Ø±ÛŒØ¯Ø§Ø±ÛŒ Ø´Ø¯Ù‡: $<span id="assetValue">0</span></p>
      <p>Ø³ÙˆØ¯/Ø¶Ø±Ø± Ú©Ù„: $<span id="profitLoss">0</span></p>
    </div>
    <div class="info" style="margin-top:10px;">
      <button id="transferToWalletBtn" class="btn" style="background-color:#ffc107; color:black; padding:10px 10px; font-size:15px; border-radius:5px;">Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ğŸ“¤</button>
      <button id="transferFromWalletBtn" class="btn" style="background-color:#6f42c1; color:white; padding:10px 10px; font-size:15px; border-radius:5px;">Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„ğŸ“¥</button>
    </div>
    <div class="info" style="margin-top:10px;">
      <button id="resetBtn" class="btn" style="background-color:#ff4d4d; color:white;">Ø±ÛŒØ³Øª Ø¨Ø§Ø²ÛŒ ğŸ”„</button>
      <button id="burnBalanceBtn" class="btn" style="background-color:#ff6600; color:white; margin-right:10px;">Ø³ÙˆØ²Ø§Ù†Ø¯Ù† Ø¯Ù„Ø§Ø± ğŸ”¥</button>
    </div>
    <div class="info" style="margin-top:10px;">
      <span class="tab" id="historyTab"> ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ğŸ“œ</span>
    </div>
    <div id="historyCard">
      <h3 style="color:black;">ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª</h3>
      <table>
        <thead>
          <tr>
            <th>Ø§Ø±Ø²</th>
            <th>ØªØ§Ø±ÛŒØ®</th>
            <th>Ø³ÙˆØ¯/Ø²ÛŒØ§Ù† Ù…Ø­Ù‚Ù‚â€ŒØ´Ø¯Ù‡</th>
          </tr>
        </thead>
        <tbody id="historyList"></tbody>
      </table>
      <small style="color:black;">Ø¨Ø±Ø§ÛŒ Ø¨Ø³ØªÙ†ØŒ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯</small>
    </div>
  </div>
  <script>
    /***********************
     * Globals & Constants *
     ***********************/
    const rsiPeriod = 14;
    const smaPeriod = 50;
    const globalMaxHistory = 200;
    const timeFrameConfigs = {
      live:  { maxPoints: 50,  interval: 2000, timeframe: 'live' },
      hour1: { maxPoints: 80,  interval: 3000, timeframe: 'hour1' },
      hour4: { maxPoints: 110, interval: 4000, timeframe: 'hour4' },
      day1:  { maxPoints: 140, interval: 5000, timeframe: 'day1' },
      week1: { maxPoints: 150, interval: 6000, timeframe: 'week1' }
    };
    const volatilityUp = 0.01;
    const volatilityDown = 0.009;
    const cycleLength = 2;
    const minDominance = 40;
    const maxDominance = 70;
    const minCorrelation = 0.30;
    const maxCorrelation = 0.80;
    const independentVolatility = 0.01;
    /***********************
     * State               *
     ***********************/
    let virtualDay = 1, virtualMonth = 1, virtualYear = 2022;
    let moveCounter = 0;
    let balance = 1000;
    let isPriceFrozen = false;
    let traderName = "Ù¾Ù„ÛŒØ±";
    let initialBalance = 1000;
    let liquidityPool = 100000;
    let currentBitcoinDominance = 40;
    let lastUpdatedMonth = virtualMonth;
    let currentConfig = timeFrameConfigs.live;
    let currentIntervalId = null;
    let currentCoin = 'bitcoin';
    let personalCoinKey = null;
    let limitOrders = [];
    let wallet = {};
    let tradeHistory = [];
    // Chart references
    let priceChart = null;
    let candlestickSeries = null;
    let smaSeries = null;
    /***********************
     * Utilities           *
     ***********************/
    function calculateRSI(data, period) {
      const rsi = [];
      for (let i = 0; i < data.length; i++) {
        if (i < period) { rsi.push(null); continue; }
        let gains = 0, losses = 0;
        for (let j = i - period + 1; j <= i; j++) {
          const diff = data[j] - data[j - 1];
          if (diff >= 0) gains += diff; else losses -= diff;
        }
        const avgGain = gains / period;
        const avgLoss = losses / period;
        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        rsi.push(Number((100 - (100 / (1 + rs))).toFixed(2)));
      }
      return rsi;
    }
    function calculateSMA(data, period) {
      const sma = [];
      for (let i = 0; i < data.length; i++) {
        if (i < period - 1) { sma.push(null); continue; }
        let sum = 0;
        for (let j = i - period + 1; j <= i; j++) sum += data[j];
        sma.push(sum / period);
      }
      return sma;
    }
    function formatMarketCap(valueInMillions) {
      if (valueInMillions >= 1000000) return (valueInMillions / 1000000).toFixed(1) + "T";
      if (valueInMillions >= 1000)    return (valueInMillions / 1000).toFixed(1) + "B";
      return valueInMillions.toFixed(1) + "M";
    }
    function formatTotalSupply(value) {
      if (value >= 1_000_000_000) return (value / 1_000_000_000).toFixed(2) + "B";
      if (value >= 1_000_000)     return (value / 1_000_000).toFixed(2) + "M";
      return value.toLocaleString();
    }
    function updateCalendarDisplay(day, month, year) {
      document.getElementById("virtualDayDisplay").innerText = `${day}/${month}/${year}`;
    }
    /***********************
     * Core Data           *
     ***********************/
    function createInitialTimeframeData(price) {
      return {
        labels: [1],
        priceData: [price],
        barData: [0],
        rsiData: calculateRSI([price], rsiPeriod),
        smaData: calculateSMA([price], smaPeriod)
      };
    }
    let coins = {
      bitcoin: {
        name: "Ø¨ÛŒØªÚ©ÙˆÛŒÙ†", totalSupply: 21000000, livePrice: 16000,
        coinAmount: 0, avgPrice: 0, stopLossPrice: 0,
        price24hAgo: 16000, cycleStep: 0,
        timeframes: {
          live:  createInitialTimeframeData(16000),
          hour1: createInitialTimeframeData(16000),
          hour4: createInitialTimeframeData(16000),
          day1:  createInitialTimeframeData(16000),
          week1: createInitialTimeframeData(16000)
        }
      },
      ethereum: {
        name: "Ø§ØªØ±ÛŒÙˆÙ…", totalSupply: 120000000, livePrice: 1100,
        coinAmount: 0, avgPrice: 0, stopLossPrice: 0,
        price24hAgo: 1100, cycleStep: 0,
        timeframes: {
          live:  createInitialTimeframeData(1100),
          hour1: createInitialTimeframeData(1100),
          hour4: createInitialTimeframeData(1100),
          day1:  createInitialTimeframeData(1100),
          week1: createInitialTimeframeData(1100)
        }
      },
      binance: {
        name: "Ø¨Ø§ÛŒÙ†Ù†Ø³ Ú©ÙˆÛŒÙ†", totalSupply: 140000000, livePrice: 200,
        coinAmount: 0, avgPrice: 0, stopLossPrice: 0,
        price24hAgo: 200, cycleStep: 0,
        timeframes: {
          live:  createInitialTimeframeData(200),
          hour1: createInitialTimeframeData(200),
          hour4: createInitialTimeframeData(200),
          day1:  createInitialTimeframeData(200),
          week1: createInitialTimeframeData(200)
        }
      }
    };
    function getCurrentCoinData() { return coins[currentCoin]; }
    /******************************
     * Support/Resistance (SR)    *
     ******************************/
    const srSeriesMap = new Map();
    function detectSupportResistance(prices, leftBars = 15, rightBars = 15) {
      const supports = [], resistances = [];
      for (let i = leftBars; i < prices.length - rightBars; i++) {
        let isSupport = true, isResistance = true;
        const current = prices[i];
        for (let j = 1; j <= leftBars; j++) {
          if (prices[i - j] <= current) isSupport = false;
          if (prices[i - j] >= current) isResistance = false;
        }
        for (let j = 1; j <= rightBars; j++) {
          if (prices[i + j] <= current) isSupport = false;
          if (prices[i + j] >= current) isResistance = false;
        }
        if (isSupport)     supports.push({ index: i, price: current });
        if (isResistance)  resistances.push({ index: i, price: current });
      }
      return { supports, resistances };
    }
    function clearSRLines(chart) {
      if (chart === priceChart) {
        const seriesList = srSeriesMap.get('priceChart') || [];
        seriesList.forEach(series => chart.removeSeries(series));
        srSeriesMap.set('priceChart', []);
      }
    }
    function drawSupportResistanceLines(chart, prices, options = {}) {
      const leftBars = options.leftBars || 15;
      const rightBars = options.rightBars || 15;
      const secondsPerBar = options.secondsPerBar || 60;
      clearSRLines(chart);
      if (!Array.isArray(prices) || prices.length < leftBars + rightBars + 1) return;
      const { supports, resistances } = detectSupportResistance(prices, leftBars, rightBars);
      const latestSupport = supports.length > 0 ? supports[supports.length - 1] : null;
      const latestResistance = resistances.length > 0 ? resistances[resistances.length - 1] : null;
      const timeBase = Math.floor(Date.now() / 1000) - prices.length * secondsPerBar;
      const chartEndTime = timeBase + (prices.length - 1) * secondsPerBar;
      const newSeriesList = [];
      if (latestSupport) {
        const levelTime = timeBase + latestSupport.index * secondsPerBar;
        const series = chart.addLineSeries({ color: '#233dee', lineWidth: 2, priceLineVisible: false, lastValueVisible: false });
        series.setData([{ time: levelTime, value: latestSupport.price }, { time: chartEndTime, value: latestSupport.price }]);
        newSeriesList.push(series);
      }
      if (latestResistance) {
        const levelTime = timeBase + latestResistance.index * secondsPerBar;
        const series = chart.addLineSeries({ color: '#e62e2e', lineWidth: 2, priceLineVisible: false, lastValueVisible: false });
        series.setData([{ time: levelTime, value: latestResistance.price }, { time: chartEndTime, value: latestResistance.price }]);
        newSeriesList.push(series);
      }
      if (chart === priceChart) srSeriesMap.set('priceChart', newSeriesList);
    }
    /***********************
     * Chart Init/Update   *
     ***********************/
    function initPriceChart() {
      const container = document.getElementById('priceChart');
      priceChart = LightweightCharts.createChart(container, {
        layout: { backgroundColor: '#0d1b2a', textColor: 'white' },
        grid: { vertLines: { color: '#1e3a5f' }, horzLines: { color: '#1e3a5f' } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { borderColor: '#444', scaleMargins: { top: 0.1, bottom: 0.2 }, textColor: '#666666' },
        timeScale: { borderColor: '#444', timeVisible: true, secondsVisible: false, textColor: '#666666' },
        handleScroll: { mouseWheel: true, pressedMouseMove: true },
        handleScale: { axisPressedMouseMove: true, mouseWheel: true, pinch: true },
      });
      candlestickSeries = priceChart.addCandlestickSeries({
        upColor: '#26a69a', downColor: '#ef5350', borderVisible: false,
        wickUpColor: '#26a69a', wickDownColor: '#ef5350',
      });
      smaSeries = priceChart.addLineSeries({ color: '#FF9800', lineWidth: 1 });
    }
    function updatePriceChart() {
      const coin = getCurrentCoinData();
      const tfData = coin.timeframes[currentConfig.timeframe];
      const data = tfData.priceData.map((price, i) => {
        const time = Math.floor(Date.now() / 1000) - (tfData.priceData.length - i) * 60;
        const open = i === 0 ? price : tfData.priceData[i - 1];
        return { time, open, high: Math.max(price, open), low: Math.min(price, open), close: price };
      });
      const maxPoints = currentConfig.maxPoints || 50;
      candlestickSeries.setData(data.slice(-maxPoints));
      const smaData = tfData.priceData.map((p, i) => ({
        time: Math.floor(Date.now() / 1000) - (tfData.priceData.length - i) * 60,
        value: tfData.smaData[i],
      })).filter(d => d.value !== null);
      smaSeries.setData(smaData.length > 0 ? smaData.slice(-currentConfig.maxPoints) : []);
      if (data.length > 0) priceChart.timeScale().fitContent();
      drawSupportResistanceLines(priceChart, tfData.priceData);
    }
    /**************************
     * Dominance & Correlation *
     **************************/
    function calculateBitcoinDominance(currentMonth) {
      const cycleIndex = (currentMonth - 1) % 4;
      switch (cycleIndex) {
        case 0: return 40;
        case 1: return 50;
        case 2: return 60;
        case 3: return 70;
        default: return 40;
      }
    }
    function calculateCorrelationFromDominance(dominance) {
      const slope = (maxCorrelation - minCorrelation) / (maxDominance - minDominance);
      const c = slope * (dominance - minDominance) + minCorrelation;
      return Math.min(Math.max(c, minCorrelation), maxCorrelation);
    }
    function getCyclicFactor(currentStep, cycleLen) {
      const phase = (currentStep % cycleLen) / cycleLen;
      if (phase < 0.5) return 1 + (phase * 1.2) * 0.052 + 0.002 * Math.sin(phase * Math.PI);
      const sub = (phase - 0.5) * 1.2;
      return 1 - (sub * 0.047) + 0.002 * Math.sin(sub * Math.PI);
    }
    /***********************
     * Wallet & History    *
     ***********************/
    function updateWalletDisplay() {
      const walletList = document.getElementById("walletList");
      if (!walletList) return;
      walletList.innerHTML = '';
      if (Object.keys(wallet).length === 0) {
        walletList.innerHTML = '<li style="text-align: center; color: gray;">Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª</li>';
        return;
      }
      for (const coinKey in wallet) {
        if (coins[coinKey]) {
          const coinInfo = coins[coinKey];
          const walletAmount = wallet[coinKey].amount;
          const walletAvgPrice = wallet[coinKey].avgPrice;
          const currentValue = walletAmount * coinInfo.livePrice;
          const pnl = (coinInfo.livePrice - walletAvgPrice) * walletAmount;
          const li = document.createElement('li');
          li.innerHTML = `
            <strong>${coinInfo.name}</strong><br>
            ØªØ¹Ø¯Ø§Ø¯: ${walletAmount.toFixed(4)}<br>
            Ù‚ÛŒÙ…Øª Ø®Ø±ÛŒØ¯ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†: $${walletAvgPrice.toFixed(2)}<br>
            Ø§Ø±Ø²Ø´ ÙØ¹Ù„ÛŒ: $${currentValue.toFixed(2)}<br>
            Ø³ÙˆØ¯/Ø¶Ø±Ø±: $${pnl.toFixed(2)}
          `;
          walletList.appendChild(li);
        }
      }
    }
    function addTradeHistoryRecord(coinKey, pnlValue) {
      const coinName = coins[coinKey]?.name || 'â€”';
      const dateStr = `${virtualDay}/${virtualMonth}/${virtualYear}`;
      const pnlStr = (pnlValue >= 0 ? '+' : '') + pnlValue.toFixed(2) + '$';
      tradeHistory.push({ coin: coinName, date: dateStr, pnl: pnlStr });
      renderHistory();
      saveGame();
    }
    function renderHistory() {
      const tbody = document.getElementById("historyList");
      if (!tbody) return;
      tbody.innerHTML = "";
      if (tradeHistory.length === 0) {
        tbody.innerHTML = `<tr><td colspan="3" style="color:gray;">Ù‡ÛŒÚ† Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒØ§ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡</td></tr>`;
        return;
      }
      tradeHistory.slice().reverse().forEach(item => {
        const row = `<tr>
          <td>${item.coin}</td>
          <td>${item.date}</td>
          <td>${item.pnl}</td>
        </tr>`;
        tbody.innerHTML += row;
      });
    }
    function resetMonthlyHistory() {
      tradeHistory = [];
      renderHistory();
      saveGame();
    }
    /***********************
     * Display & Updates   *
     ***********************/
    function getUserLevel(pnlPercent) {
      if (pnlPercent > 200) return { level: "Ø¬Ø§Ø¯ÙˆÚ¯Ø±",   stars: "â­â­â­â­â­" };
      if (pnlPercent > 100) return { level: "Ø­Ø±ÙÙ‡ Ø§ÛŒ",   stars: "â­â­â­â­" };
      if (pnlPercent > 50)  return { level: "Ù¾ÛŒØ´Ø±ÙØªÙ‡",   stars: "â­â­â­" };
      if (pnlPercent > 20)  return { level: "Ù…ØªÙˆØ³Ø·",     stars: "â­â­" };
      return { level: "ØªØ§Ø²Ù‡ Ú©Ø§Ø±", stars: "â­" };
    }
    function updateCoinPercentages() {
      const coin = getCurrentCoinData();
      const totalBoughtAmount = coin.coinAmount + (wallet[currentCoin]?.amount || 0);
      const percentBought = (totalBoughtAmount / coin.totalSupply) * 100;
      const percentRemaining = 100 - percentBought;
      document.getElementById("percentBought").innerText = percentBought.toFixed(4) + "%";
      document.getElementById("percentRemaining").innerText = percentRemaining.toFixed(4) + "%";
      document.getElementById("liquidityPoolValue").innerText = liquidityPool.toLocaleString();
    }
    function updateUpgradeButtons() {
      if (currentCoin !== personalCoinKey) return;
      const coin = getCurrentCoinData();
      const upgrades = coin.upgrades || [];
      const upgradeButtons = {
        'upgradeTpsBtn': 'TPS',
        'upgradeSecurityBtn': 'Security',
        'upgradeConsensusBtn': 'Consensus',
        'upgradeNftBtn': 'NFT',
        'upgradeMarketingBtn': 'Marketing'
      };
      for (const [buttonId, upgradeName] of Object.entries(upgradeButtons)) {
        const button = document.getElementById(buttonId);
        if (!button) continue;
        // Ø­Ø°Ù event listener Ù‚Ø¨Ù„ÛŒ (Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯) Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø§Ù†Ø¨Ø§Ø´Øª
        button.replaceWith(button.cloneNode(true)); // Ø±Ø§Ù‡ Ø­Ù„ Ø³Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø­Ø°Ù event listener
        const newButton = document.getElementById(buttonId); // Ú¯Ø±ÙØªÙ† Ø¯Ú©Ù…Ù‡ Ø¬Ø¯ÛŒØ¯

        if (upgrades.includes(upgradeName)) {
          newButton.disabled = true;
          newButton.textContent = 'âœ…';
          newButton.onclick = null; // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø¹Ø¯Ù… Ø§ØªØµØ§Ù„ ØªØ§Ø¨Ø¹
        } else {
          newButton.disabled = false;
          newButton.textContent = 'Ø®Ø±ÛŒØ¯';
          newButton.onclick = () => purchaseUpgrade(upgradeName); // Ø§ØªØµØ§Ù„ ØªØ§Ø¨Ø¹ Ø®Ø±ÛŒØ¯
        }
      }
    }
    function updateUpgradeTabStatus() {
      const upgradeTab = document.getElementById('upgradeTab');
      upgradeTab.onclick = null;
      if (currentCoin === personalCoinKey) {
        upgradeTab.classList.remove('upgrade-tab-inactive');
        upgradeTab.style.opacity = '1';
        upgradeTab.style.cursor = 'pointer';
        upgradeTab.onclick = showUpgradeCard;
      } else {
        upgradeTab.classList.add('upgrade-tab-inactive');
        upgradeTab.style.opacity = '0.5';
        upgradeTab.style.cursor = 'not-allowed';
      }
    }
    function updateDisplay() {
      const coin = getCurrentCoinData();
      document.getElementById("balance").innerText = balance.toFixed(2);
      document.getElementById("currentPrice").innerText = coin.livePrice.toFixed(2);
      const change24h = ((coin.livePrice - coin.price24hAgo) / coin.price24hAgo) * 100;
      const change24hElement = document.getElementById("priceChange24h");
      change24hElement.innerText = (change24h >= 0 ? '+' : '') + change24h.toFixed(2) + '%';
      change24hElement.style.color = change24h >= 0 ? 'lightgreen' : 'tomato';
      document.getElementById("coinAmount").innerText = coin.coinAmount.toFixed(4);
      document.getElementById("avgPrice").innerText = coin.avgPrice.toFixed(2);
      const assetValue = coin.coinAmount * coin.livePrice;
      document.getElementById("assetValue").innerText = assetValue.toFixed(2);
      const profitLoss = (coin.livePrice - coin.avgPrice) * coin.coinAmount;
      document.getElementById("profitLoss").innerText = profitLoss.toFixed(2);
      document.getElementById("stopLossDisplay").innerText = coin.coinAmount > 0 ? coin.stopLossPrice.toFixed(2) : "â€”";
      const totalBoughtByUser = coin.coinAmount + (wallet[currentCoin]?.amount || 0);
      document.getElementById("buyBtn").disabled  = (balance <= 0 || totalBoughtByUser >= coin.totalSupply);
      document.getElementById("sellBtn").disabled = (coin.coinAmount <= 0);
      document.getElementById("currentBalanceProfile").innerText = balance.toFixed(2);
      const pnlPercent = ((balance - initialBalance) / initialBalance) * 100;
      const pnlElement = document.getElementById("totalPnLPercent");
      pnlElement.innerText = (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%';
      pnlElement.style.color = pnlPercent >= 0 ? 'green' : 'red';
      const userLevelInfo = getUserLevel(pnlPercent);
      document.getElementById("userLevel").innerText = userLevelInfo.level;
      document.getElementById("userStars").innerText = userLevelInfo.stars;
      updateCoinPercentages();
      updateWalletDisplay();
      updateUpgradeButtons();
    }
    /***********************
     * Persistence         *
     ***********************/
    function saveGame() {
      const data = {
        balance, virtualDay, virtualMonth, virtualYear, moveCounter,
        coins, currentCoin, personalCoinKey, isPriceFrozen, liquidityPool,
        traderName, initialBalance, limitOrders, wallet,
        currentBitcoinDominance, lastUpdatedMonth,
        personalCoinUpgrades: coins[personalCoinKey]?.upgrades || [],
        tradeHistory
      };
      localStorage.setItem("nasrTradingGameSave", JSON.stringify(data));
    }
    function loadGame() {
      const saved = localStorage.getItem("nasrTradingGameSave");
      if (!saved) return;
      const data = JSON.parse(saved);
      balance = data.balance;
      virtualDay = data.virtualDay || 1;
      virtualMonth = data.virtualMonth || 1;
      virtualYear = data.virtualYear || 2022;
      moveCounter = data.moveCounter || 0;
      coins = data.coins;
      currentCoin = data.currentCoin || 'bitcoin';
      personalCoinKey = data.personalCoinKey || null;
      isPriceFrozen = data.isPriceFrozen || false;
      liquidityPool = data.liquidityPool || 100000;
      traderName = data.traderName || "Ù¾Ù„ÛŒØ±";
      initialBalance = data.initialBalance || 1000;
      limitOrders = data.limitOrders || [];
      wallet = data.wallet || {};
      currentBitcoinDominance = (data.currentBitcoinDominance !== undefined) ? data.currentBitcoinDominance : 40;
      lastUpdatedMonth = (data.lastUpdatedMonth !== undefined) ? data.lastUpdatedMonth : virtualMonth;
      if (personalCoinKey && data.personalCoinUpgrades) {
        if (!coins[personalCoinKey]) coins[personalCoinKey] = { upgrades: [] };
        coins[personalCoinKey].upgrades = data.personalCoinUpgrades;
      }
      tradeHistory = Array.isArray(data.tradeHistory) ? data.tradeHistory : [];
      renderHistory();
      const freezeBtn = document.getElementById('freezePriceBtn');
      freezeBtn.innerText = isPriceFrozen ? 'â–¶ï¸' : 'â¸ï¸';
      freezeBtn.title = isPriceFrozen ? 'Ù‚ÛŒÙ…Øª ÙØ±ÛŒØ² Ø´Ø¯Ù‡ â€” Ù¾Ø§Ù…Ù¾/Ø¯Ø§Ù…Ù¾ ØºÛŒØ±ÙØ¹Ø§Ù„' : 'ÙØ±ÛŒØ² Ù‚ÛŒÙ…Øª (Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù¾Ø§Ù…Ù¾/Ø¯Ø§Ù…Ù¾)';
      if (personalCoinKey && coins[personalCoinKey]) {
        const pcTab = document.getElementById("personalCoinTab");
        pcTab.innerText = coins[personalCoinKey].name;
        pcTab.style.display = "inline-block";
      }
      document.querySelectorAll('.coin-tab').forEach(tab => tab.classList.remove('active'));
      let marketCapInMillions = 0;
      if (currentCoin === 'bitcoin') {
        document.getElementById('coinNameTab').classList.add('active');
        marketCapInMillions = (coins.bitcoin.livePrice * coins.bitcoin.totalSupply) / 1_000_000;
        document.getElementById("dominanceDisplay").style.display = 'block';
        document.getElementById("bitcoinDominanceValue").innerText = currentBitcoinDominance.toFixed(2) + "%";
      } else {
        document.getElementById("dominanceDisplay").style.display = 'none';
        if (currentCoin === 'ethereum') {
          document.getElementById('coinEthereumTab').classList.add('active');
          marketCapInMillions = (coins.ethereum.livePrice * coins.ethereum.totalSupply) / 1_000_000;
        } else if (currentCoin === 'binance') {
          document.getElementById('coinBinanceTab').classList.add('active');
          marketCapInMillions = (coins.binance.livePrice * coins.binance.totalSupply) / 1_000_000;
        } else if (personalCoinKey && currentCoin === personalCoinKey) {
          document.getElementById('personalCoinTab').classList.add('active');
          marketCapInMillions = (coins[personalCoinKey].livePrice * coins[personalCoinKey].totalSupply) / 1_000_000;
        }
      }
      document.getElementById("marketCap").innerText = formatMarketCap(marketCapInMillions);
      updateUpgradeTabStatus();
      updateUpgradeButtons();
    }
    /***********************
     * Orders & Trading    *
     ***********************/
    function switchToCoin(coinKey) {
  if (!coins[coinKey]) return;
  currentCoin = coinKey;
  const newCoin = getCurrentCoinData(); // Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø±Ø² Ø¬Ø¯ÛŒØ¯ Ú¯Ø±ÙØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
  document.getElementById("coinNameDisplay").innerText = newCoin.name;

  // --- Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ø§ÛŒØ¯ Ø¯Ø±Ø³Øª Ø¨Ø¹Ø¯ Ø§Ø² Ú¯Ø±ÙØªÙ† newCoin Ù‚Ø±Ø§Ø± Ø¨Ú¯ÛŒØ±Ø¯ ---
  const marketCapInMillions = (newCoin.livePrice * newCoin.totalSupply) / 1_000_000;
  document.getElementById("marketCap").innerText = formatMarketCap(marketCapInMillions);
  // ---

  const dominanceDisplay = document.getElementById("dominanceDisplay");
  if (coinKey === 'bitcoin') {
    dominanceDisplay.style.display = 'block';
    document.getElementById("bitcoinDominanceValue").innerText = currentBitcoinDominance.toFixed(2) + "%";
  } else {
    // Ù…Ù‡Ù…: Ø§Ú¯Ø± Ø§Ø±Ø² Ø¬Ø¯ÛŒØ¯ Ø¨ÛŒØªÚ©ÙˆÛŒÙ† Ù†Ø¨ÙˆØ¯ØŒ Ø¨Ø§ÛŒØ¯ Ù‚Ø³Ù…Øª Ø¯Ø§Ù…ÛŒÙ†Ù†Ø³ Ø¨ÛŒØªÚ©ÙˆÛŒÙ† Ù…Ø®ÙÛŒ Ø´ÙˆØ¯
    dominanceDisplay.style.display = 'none';
  }
  document.getElementById("totalSupplyDisplay").innerText = formatTotalSupply(newCoin.totalSupply);
  // ØªØ£ÛŒÛŒØ¯ Ø§ÛŒÙ†Ú©Ù‡ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø¯Ø±ØµØ¯ Ø§Ø±Ø² Ù†ÛŒØ² Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´ÙˆØ¯
  updateCoinPercentages();

  // Ø¨Ù‚ÛŒÙ‡ Ú©Ø¯ ØªØ§Ø¨Ø¹ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ø¨Ø§Ù‚ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ø¯
  updateDisplay();
  updatePriceChart();
  const tfData = newCoin.timeframes[currentConfig.timeframe];
  rsiChart.data.labels = tfData.labels.slice(-currentConfig.maxPoints);
  rsiChart.data.datasets[0].data = tfData.rsiData.slice(-currentConfig.maxPoints);
  rsiChart.update();

  document.querySelectorAll('.coin-tab').forEach(tab => tab.classList.remove('active'));
  if (coinKey === 'bitcoin') document.getElementById('coinNameTab').classList.add('active');
  else if (coinKey === 'ethereum') document.getElementById('coinEthereumTab').classList.add('active');
  else if (coinKey === 'binance') document.getElementById('coinBinanceTab').classList.add('active');
  else if (personalCoinKey && coinKey === personalCoinKey) document.getElementById('personalCoinTab').classList.add('active');

  updateUpgradeTabStatus();
    }
    function applyPriceChangeForCoin(coinKey, newPrice) {
      const coin = coins[coinKey];
      if (!coin) return;
      coin.livePrice = newPrice;
      const liveTf = coin.timeframes.live;
      const timeLabel = liveTf.labels.length ? Number(liveTf.labels[liveTf.labels.length - 1]) + 1 : 1;
      liveTf.labels.push(timeLabel);
      liveTf.priceData.push(newPrice);
      liveTf.barData.push(newPrice - (liveTf.priceData.length > 1 ? liveTf.priceData[liveTf.priceData.length - 2] : newPrice));
      liveTf.rsiData = calculateRSI(liveTf.priceData, rsiPeriod);
      liveTf.smaData = calculateSMA(liveTf.priceData, smaPeriod);
      if (coinKey === 'bitcoin' && moveCounter > 0) {
        const prevPrice = liveTf.priceData[liveTf.priceData.length - 2] || coin.livePrice;
        const priceChangeFactor = newPrice / prevPrice;
        liquidityPool *= priceChangeFactor;
      }
      updateHigherTimeframesForCoin(coinKey, newPrice);
      for (const tf of ['live', 'hour1', 'hour4', 'day1', 'week1']) {
        const data = coin.timeframes[tf];
        if (data.labels.length > globalMaxHistory) {
          data.labels.shift(); data.priceData.shift(); data.barData.shift(); data.rsiData.shift(); data.smaData.shift();
        }
      }
      checkLimitOrdersForCoin(coinKey, newPrice);
      if (coinKey === currentCoin && coin.coinAmount > 0 && newPrice <= coin.stopLossPrice) {
        const coinsToSell = coin.coinAmount;
        const realizedPnl = (newPrice - coin.avgPrice) * coinsToSell;
        balance += coinsToSell * newPrice;
        coin.coinAmount = 0;
        coin.avgPrice = 0;
        addTradeHistoryRecord(coinKey, realizedPnl);
        updateDisplay();
        updateCoinPercentages();
        alert(`Ø­Ø¯ Ø¶Ø±Ø± ÙØ¹Ø§Ù„ Ø´Ø¯. ÙØ±ÙˆØ´ ${coinsToSell.toFixed(4)} Ø³Ù‡Ù… ${coin.name} Ø¨Ù‡ Ù‚ÛŒÙ…Øª $${newPrice.toFixed(2)} Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯.`);
      }
      if (coinKey === currentCoin) updateDisplay();
    }
    function updateHigherTimeframesForCoin(coinKey, newLivePrice) {
      const coin = coins[coinKey];
      if (moveCounter % 2 === 0) {
        const tf1h = coin.timeframes.hour1;
        const t = tf1h.labels.length ? tf1h.labels[tf1h.labels.length - 1] + 1 : 1;
        tf1h.labels.push(t);
        tf1h.priceData.push(newLivePrice);
        tf1h.barData.push(newLivePrice - (tf1h.priceData.length > 1 ? tf1h.priceData[tf1h.priceData.length - 2] : newLivePrice));
        tf1h.rsiData = calculateRSI(tf1h.priceData, rsiPeriod);
        tf1h.smaData = calculateSMA(tf1h.priceData, smaPeriod);
      }
      if (moveCounter % 4 === 0) {
        const tf4h = coin.timeframes.hour4;
        const t = tf4h.labels.length ? tf4h.labels[tf4h.labels.length - 1] + 1 : 1;
        tf4h.labels.push(t);
        tf4h.priceData.push(newLivePrice);
        tf4h.barData.push(newLivePrice - (tf4h.priceData.length > 1 ? tf4h.priceData[tf4h.priceData.length - 2] : newLivePrice));
        tf4h.rsiData = calculateRSI(tf4h.priceData, rsiPeriod);
        tf4h.smaData = calculateSMA(tf4h.priceData, smaPeriod);
      }
      if (moveCounter % 5 === 0) {
        const tf1d = coin.timeframes.day1;
        const t = tf1d.labels.length ? tf1d.labels[tf1d.labels.length - 1] + 1 : 1;
        tf1d.labels.push(t);
        tf1d.priceData.push(newLivePrice);
        tf1d.barData.push(newLivePrice - (tf1d.priceData.length > 1 ? tf1d.priceData[tf1d.priceData.length - 2] : newLivePrice));
        tf1d.rsiData = calculateRSI(tf1d.priceData, rsiPeriod);
        tf1d.smaData = calculateSMA(tf1d.priceData, smaPeriod);
      }
      if (moveCounter % 6 === 0) {
        const tf1w = coin.timeframes.week1;
        const t = tf1w.labels.length ? tf1w.labels[tf1w.labels.length - 1] + 1 : 1;
        tf1w.labels.push(t);
        tf1w.priceData.push(newLivePrice);
        tf1w.barData.push(newLivePrice - (tf1w.priceData.length > 1 ? tf1w.priceData[tf1w.priceData.length - 2] : newLivePrice));
        tf1w.rsiData = calculateRSI(tf1w.priceData, rsiPeriod);
        tf1w.smaData = calculateSMA(tf1w.priceData, smaPeriod);
      }
    }
    function checkLimitOrdersForCoin(coinKey, newPrice) {
      for (let i = limitOrders.length - 1; i >= 0; i--) {
        const order = limitOrders[i];
        if (order.coinKey !== coinKey) continue;
        const coin = coins[coinKey];
        if (order.type === 'buy' && newPrice <= order.price) {
          const amountToSpend = order.amount;
          if (balance >= amountToSpend) {
            const coinsBought = amountToSpend / newPrice;
            const onePercentSupply = coin.totalSupply * 0.01;
            balance -= amountToSpend;
            coin.coinAmount += coinsBought;
            coin.avgPrice = coin.coinAmount > 0
              ? ((coin.avgPrice * (coin.coinAmount - coinsBought)) + (newPrice * coinsBought)) / coin.coinAmount
              : newPrice;
            if (!isPriceFrozen && coinsBought >= onePercentSupply) {
              const newPumpedPrice = newPrice * 1.05;
              applyPriceChangeForCoin(coinKey, newPumpedPrice);
              if (coinKey === 'bitcoin') coins.bitcoin.livePrice = newPumpedPrice;
              alert(`ğŸ”¥ Ø®Ø±ÛŒØ¯ Ø¨Ø²Ø±Ú¯ (${(coinsBought / coin.totalSupply * 100).toFixed(2)}%) Ø±ÙˆÛŒ ${coin.name}!`);
            } else {
              if (coinKey === currentCoin) { updateDisplay(); updateCoinPercentages(); }
            }
            limitOrders.splice(i, 1);
            alert(`âœ… Ø§ÙˆØ±Ø¯Ø± Ø®Ø±ÛŒØ¯ Ù„ÛŒÙ…ÛŒØª Ø´Ù…Ø§ Ø¨Ù‡ Ù‚ÛŒÙ…Øª $${order.price} Ø¨Ø±Ø§ÛŒ ${coin.name} Ø§Ø¬Ø±Ø§ Ø´Ø¯.`);
          }
        } else if (order.type === 'sell' && newPrice >= order.price) {
          const coinsToSell = order.amount / newPrice;
          if (coin.coinAmount >= coinsToSell) {
            const onePercentSupply = coin.totalSupply * 0.01;
            const realizedPnl = (newPrice - coin.avgPrice) * coinsToSell;
            balance += order.amount;
            coin.coinAmount -= coinsToSell;
            if (coin.coinAmount <= 0) { coin.coinAmount = 0; coin.avgPrice = 0; }
            addTradeHistoryRecord(coinKey, realizedPnl);
            if (!isPriceFrozen && coinsToSell >= onePercentSupply) {
              const newDumpedPrice = newPrice * 0.95;
              applyPriceChangeForCoin(coinKey, newDumpedPrice);
              if (coinKey === 'bitcoin') coins.bitcoin.livePrice = newDumpedPrice;
              alert(`ğŸ“‰ ÙØ±ÙˆØ´ Ø¨Ø²Ø±Ú¯ (${(coinsToSell / coin.totalSupply * 100).toFixed(2)}%) Ø±ÙˆÛŒ ${coin.name}!`);
            } else {
              if (coinKey === currentCoin) { updateDisplay(); updateCoinPercentages(); }
            }
            limitOrders.splice(i, 1);
            alert(`âœ… Ø§ÙˆØ±Ø¯Ø± ÙØ±ÙˆØ´ Ù„ÛŒÙ…ÛŒØª Ø´Ù…Ø§ Ø¨Ù‡ Ù‚ÛŒÙ…Øª $${order.price} Ø¨Ø±Ø§ÛŒ ${coin.name} Ø§Ø¬Ø±Ø§ Ø´Ø¯.`);
          }
        }
      }
    }
    /***********************
     * Wallet Transfers    *
     ***********************/
    function transferToWallet() {
      const coin = getCurrentCoinData();
      const percent = parseInt(document.getElementById("tradePercent").value);
      const amountToTransfer = coin.coinAmount * (percent / 100);
      if (amountToTransfer <= 0) { alert("Ù…Ù‚Ø¯Ø§Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 0 Ø¨Ø§Ø´Ø¯."); return; }
      if (coin.coinAmount < amountToTransfer) { alert("Ù…Ù‚Ø¯Ø§Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø±Ø² Ø¯Ø± ØµØ±Ø§ÙÛŒ Ø§Ø³Øª."); return; }
      coin.coinAmount -= amountToTransfer;
      if (!wallet[currentCoin]) wallet[currentCoin] = { amount: 0, avgPrice: 0 };
      const currentWalletAmount = wallet[currentCoin].amount;
      const currentWalletTotalValue = wallet[currentCoin].avgPrice * currentWalletAmount;
      const transferredValue = amountToTransfer * coin.avgPrice;
      const newTotalAmount = currentWalletAmount + amountToTransfer;
      const newTotalValue = currentWalletTotalValue + transferredValue;
      wallet[currentCoin].amount = newTotalAmount;
      wallet[currentCoin].avgPrice = newTotalAmount > 0 ? newTotalValue / newTotalAmount : 0;
      if (coin.coinAmount <= 0) { coin.avgPrice = 0; coin.stopLossPrice = 0; }
      updateDisplay();
      alert(`âœ… ${amountToTransfer.toFixed(4)} Ø¹Ø¯Ø¯ ${coin.name} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù…Ù†ØªÙ‚Ù„ Ø´Ø¯.`);
      saveGame();
    }
    function transferFromWallet() {
      const coin = getCurrentCoinData();
      const percent = parseInt(document.getElementById("tradePercent").value);
      if (!wallet[currentCoin]) { alert(`Ø´Ù…Ø§ Ù‡ÛŒÚ† ${coin.name} Ø¯Ø± Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù†Ø¯Ø§Ø±ÛŒØ¯.`); return; }
      const amountToTransfer = wallet[currentCoin].amount * (percent / 100);
      if (amountToTransfer <= 0) { alert("Ù…Ù‚Ø¯Ø§Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 0 Ø¨Ø§Ø´Ø¯."); return; }
      if (wallet[currentCoin].amount < amountToTransfer) { alert("Ù…Ù‚Ø¯Ø§Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø±Ø² Ø¯Ø± Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø§Ø³Øª."); return; }
      wallet[currentCoin].amount -= amountToTransfer;
      const currentCoinAmount = coin.coinAmount;
      const currentCoinTotalValue = coin.avgPrice * currentCoinAmount;
      const transferredValue = amountToTransfer * wallet[currentCoin].avgPrice;
      const newTotalAmount = currentCoinAmount + amountToTransfer;
      const newTotalValue = currentCoinTotalValue + transferredValue;
      coin.coinAmount = newTotalAmount;
      coin.avgPrice = newTotalAmount > 0 ? newTotalValue / newTotalAmount : 0;
      if (currentCoinAmount <= 0) {
        const stopLossPercent = parseInt(document.getElementById("stopLossPercent").value);
        coin.stopLossPrice = coin.avgPrice * (1 - stopLossPercent / 100);
      }
      if (wallet[currentCoin].amount <= 0) delete wallet[currentCoin];
      updateDisplay();
      alert(`âœ… ${amountToTransfer.toFixed(4)} Ø¹Ø¯Ø¯ ${coin.name} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ù‡ ØµØ±Ø§ÙÛŒ Ù…Ù†ØªÙ‚Ù„ Ø´Ø¯.`);
      saveGame();
    }
    /***********************
     * Upgrades & My Coin  *
     ***********************/
    function showUpgradeCard() {
      const upgradeCard = document.getElementById('upgradeCard');
      if (upgradeCard.style.display === 'none') { upgradeCard.style.display = 'block'; showOverlay(); }
      else { upgradeCard.style.display = 'none'; hideOverlay(); }
    }

    function purchaseUpgrade(upgradeName) {
      if (currentCoin !== personalCoinKey) { alert("Ø§Ø¨ØªØ¯Ø§ Ø§Ø±Ø² Ø´Ø®ØµÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯."); return; }
      if (balance < 1000) { alert("Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯ Ø§ÛŒÙ† Ø§Ø±ØªÙ‚Ø§Ø¡ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª! Ù†ÛŒØ§Ø² Ø¨Ù‡ 1000 Ø¯Ù„Ø§Ø± Ø¯Ø§Ø±ÛŒØ¯."); return; }
      const coin = getCurrentCoinData();
      if (!coin.upgrades) coin.upgrades = [];
      if (coin.upgrades.includes(upgradeName)) { alert("Ø§ÛŒÙ† Ø§Ø±ØªÙ‚Ø§Ø¡ Ù‚Ø¨Ù„Ø§Ù‹ Ø®Ø±ÛŒØ¯Ø§Ø±ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª."); return; }
      balance -= 1000;
      coin.upgrades.push(upgradeName);
      coin.livePrice *= 1.05; // ÛŒØ§ Ù‡Ø± ØªØ£Ø«ÛŒØ± Ø¯ÛŒÚ¯Ø±ÛŒ Ú©Ù‡ Ø¨Ø§ÛŒØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯
      for (const tf of ['live','hour1','hour4','day1','week1']) {
        const data = coin.timeframes[tf];
        if (data.priceData.length > 0) {
          data.priceData[data.priceData.length - 1] = coin.livePrice;
          data.rsiData = calculateRSI(data.priceData, rsiPeriod);
          data.smaData = calculateSMA(data.priceData, smaPeriod);
        }
      }
      updateDisplay();
      updatePriceChart();
      const activeTfData = coin.timeframes[currentConfig.timeframe];
      rsiChart.data.labels = activeTfData.labels.slice(-currentConfig.maxPoints);
      rsiChart.data.datasets[0].data = activeTfData.rsiData.slice(-currentConfig.maxPoints);
      rsiChart.update();
      alert(`ğŸ‰ Ø§Ø±ØªÙ‚Ø§Ø¡ "${upgradeName}" Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø®Ø±ÛŒØ¯Ø§Ø±ÛŒ Ø´Ø¯! Ù‚ÛŒÙ…Øª Ø§Ø±Ø² Ø´Ù…Ø§ 5% Ù¾Ø§Ù…Ù¾ Ø´Ø¯.`);
      updateUpgradeButtons(); // Ø¨Ø±Ø§ÛŒ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø¯Ú©Ù…Ù‡ Ù¾Ø³ Ø§Ø² Ø®Ø±ÛŒØ¯
      saveGame();
    }

    function createMyCoin() {
      const name = document.getElementById("coinNameInput").value.trim();
      const supply = parseFloat(document.getElementById("totalSupplyInput").value);
      const price = parseFloat(document.getElementById("listingPriceInput").value);
      const network = document.getElementById("networkSelect").value;
      if (!name || name.length < 2) { alert("Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ø§Ø±Ø² Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ø­Ø¯Ø§Ù‚Ù„ 2 Ú©Ø§Ø±Ø§Ú©ØªØ±)."); return; }
      if (isNaN(supply) || supply < 1000) { alert("ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ø³Ú©Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 1000 Ø¨Ø§Ø´Ø¯."); return; }
      if (isNaN(price) || price <= 0) { alert("Ù‚ÛŒÙ…Øª Ù„ÛŒØ³Øª Ø´Ø¯Ù† Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 0 Ø¨Ø§Ø´Ø¯."); return; }
      if (balance < 100) { alert("Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª Ø§Ø±Ø² Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª! Ù†ÛŒØ§Ø² Ø¨Ù‡ 100 Ø¯Ù„Ø§Ø± Ø¯Ø§Ø±ÛŒØ¯."); return; }
      personalCoinKey = 'mycoin_' + Date.now();
      const myCoins = supply * 0.8;
      const freeSupply = supply - myCoins;
      coins[personalCoinKey] = {
        name, totalSupply: supply, livePrice: price,
        coinAmount: myCoins, avgPrice: price, stopLossPrice: price * (1 - 5/100),
        price24hAgo: price, cycleStep: 0,
        timeframes: {
          live:  createInitialTimeframeData(price),
          hour1: createInitialTimeframeData(price),
          hour4: createInitialTimeframeData(price),
          day1:  createInitialTimeframeData(price),
          week1: createInitialTimeframeData(price)
        },
        upgrades: []
      };
      balance -= 100;
      const pcTab = document.getElementById("personalCoinTab");
      pcTab.innerText = name;
      pcTab.style.display = "inline-block";
      switchToCoin(personalCoinKey);
      const marketCapInMillions = (price * supply) / 1_000_000;
      document.getElementById("marketCap").innerText = formatMarketCap(marketCapInMillions);
      document.getElementById("totalSupplyDisplay").innerText = formatTotalSupply(supply);
      updateCoinPercentages();
      updateUpgradeTabStatus();
      updateUpgradeButtons();
      alert(`ğŸ‰ Ø§Ø±Ø² "${name}" Ø¨Ø± Ø±ÙˆÛŒ Ø´Ø¨Ú©Ù‡ "${network}" Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯!
80% (${formatTotalSupply(myCoins)} Ø³Ú©Ù‡) Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø´Ù…Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.
20% (${formatTotalSupply(freeSupply)} Ø³Ú©Ù‡) Ø¨Ø±Ø§ÛŒ ÙØ±ÙˆØ´ Ø¯Ø± Ø¨Ø§Ø²Ø§Ø± Ø¢Ø²Ø§Ø¯ Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØª.`);
      document.getElementById("myCoinForm").style.display = "none";
    }
    /***********************
     * Engine & RSI Pump   *
     ***********************/
    function updateChartContent() {
      if (isPriceFrozen) return;
      if (virtualMonth !== lastUpdatedMonth) {
        currentBitcoinDominance = calculateBitcoinDominance(virtualMonth);
        lastUpdatedMonth = virtualMonth;
        if (currentCoin === 'bitcoin') {
          document.getElementById("bitcoinDominanceValue").innerText = currentBitcoinDominance.toFixed(2) + "%";
        }
        console.log(`Ù…Ø§Ù‡ ${virtualMonth} Ø´Ø±ÙˆØ¹ Ø´Ø¯. Ø¯Ø§Ù…ÛŒÙ†Ù†Ø³ Ø¨ÛŒØªÚ©ÙˆÛŒÙ†: ${currentBitcoinDominance}%`);
      }
      const bitcoin = coins.bitcoin;
      const bias = Math.random();
      const changePercent = (bias < 0.55) ? Math.random() * volatilityUp : -Math.random() * volatilityDown;
      let newBitcoinPrice = Math.max(bitcoin.livePrice * (1 + changePercent), 0.1);
      const cyclicFactor = getCyclicFactor(bitcoin.cycleStep, cycleLength);
      newBitcoinPrice *= cyclicFactor;
      bitcoin.cycleStep = (bitcoin.cycleStep + 1) % (cycleLength * 2);
      const dynamicCorrelation = calculateCorrelationFromDominance(currentBitcoinDominance);
      const dynamicIndependentFactor = 1 - dynamicCorrelation;
      for (const key in coins) {
        const coin = coins[key];
        const independentBias = Math.random();
        const independentChangePercent = independentBias < 0.5 ? Math.random() * independentVolatility : -Math.random() * independentVolatility;
        const finalChangePercent = (changePercent * dynamicCorrelation) + (independentChangePercent * dynamicIndependentFactor);
        const newPrice = Math.max(coin.livePrice * (1 + finalChangePercent), 0.1);
        applyPriceChangeForCoin(key, newPrice);
      }
      moveCounter++;
      if (moveCounter >= 30) {
        virtualDay++;
        moveCounter = 0;
        if (virtualDay > 30) {
          virtualDay = 1;
          virtualMonth++;
          if (virtualMonth > 12) {
            virtualMonth = 1;
            virtualYear++;
          }
          resetMonthlyHistory();
        }
        updateCalendarDisplay(virtualDay, virtualMonth, virtualYear);
        coins.bitcoin.price24hAgo = coins.bitcoin.livePrice;
        const marketCapInMillions = (coins.bitcoin.livePrice * coins.bitcoin.totalSupply) / 1_000_000;
        document.getElementById("marketCap").innerText = formatMarketCap(marketCapInMillions);
      }
      // RSI-driven pump/dump
      if (!isPriceFrozen) {
        for (const coinKey in coins) {
          const coin = coins[coinKey];
          const activeTfData = coin.timeframes[currentConfig.timeframe];
          const rsiArr = activeTfData.rsiData;
          if (!rsiArr || rsiArr.length === 0) continue;
          let lastRsiValue = null;
          for (let i = rsiArr.length - 1; i >= 0; i--) {
            if (rsiArr[i] !== null) { lastRsiValue = parseFloat(rsiArr[i]); break; }
          }
          if (lastRsiValue === null) continue;
          let newPriceForPumpDump = coin.livePrice;
          let message = '';
          if (lastRsiValue <= 25) {
            newPriceForPumpDump = coin.livePrice * 1.01;
            message = `ğŸ“ˆ RSI ${coin.name} Ø¨Ù‡ ${lastRsiValue.toFixed(2)} Ø±Ø³ÛŒØ¯! Ù¾Ø§Ù…Ù¾ 2% Ø§Ø¹Ù…Ø§Ù„ Ø´Ø¯.`;
          } else if (lastRsiValue >= 75) {
            newPriceForPumpDump = coin.livePrice * 0.99;
            message = `ğŸ“‰ RSI ${coin.name} Ø¨Ù‡ ${lastRsiValue.toFixed(2)} Ø±Ø³ÛŒØ¯! Ø¯Ø§Ù…Ù¾ 2% Ø§Ø¹Ù…Ø§Ù„ Ø´Ø¯.`;
          }
          if (newPriceForPumpDump !== coin.livePrice) {
            newPriceForPumpDump = Math.max(newPriceForPumpDump, 0.1);
            applyPriceChangeForCoin(coinKey, newPriceForPumpDump);
            console.log(message);
          }
        }
      }
      if (!isPriceFrozen) {
        updateDisplay();
        updatePriceChart();
        const activeTfData = getCurrentCoinData().timeframes[currentConfig.timeframe];
        rsiChart.data.labels = activeTfData.labels.slice(-currentConfig.maxPoints);
        rsiChart.data.datasets[0].data = activeTfData.rsiData.slice(-currentConfig.maxPoints);
        rsiChart.update();
        const coin = getCurrentCoinData();
        const tfData = coin.timeframes[currentConfig.timeframe];
        const smaData = tfData.priceData.map((p, i) => ({
          time: Math.floor(Date.now() / 1000) - (tfData.priceData.length - i) * 60,
          value: tfData.smaData[i]
        })).filter(d => d.value !== null);
        smaSeries.setData(smaData.length ? smaData.slice(-currentConfig.maxPoints) : []);
      }
    }
    function setTimeFrame(frame) {
      if (currentIntervalId) clearInterval(currentIntervalId);
      currentConfig = timeFrameConfigs[frame];
      updatePriceChart();
      const coin = getCurrentCoinData();
      const tfData = coin.timeframes[frame];
      rsiChart.data.labels = tfData.labels.slice(-currentConfig.maxPoints);
      rsiChart.data.datasets[0].data = tfData.rsiData.slice(-currentConfig.maxPoints);
      rsiChart.update();
      currentIntervalId = setInterval(updateChartContent, currentConfig.interval);
    }
    /***********************
     * Overlay & UI Events *
     ***********************/
    function showOverlay() {
      if (!document.getElementById('overlay')) {
        const overlay = document.createElement('div');
        overlay.id = 'overlay';
        document.body.appendChild(overlay);
        document.body.style.overflow = 'hidden';
      }
    }
    function hideOverlay() {
      const overlay = document.getElementById('overlay');
      if (overlay) {
        overlay.remove();
        document.body.style.overflow = '';
      }
    }
    // Tabs & Cards toggles
    document.getElementById('infoTab').addEventListener('click', () => {
      const infoCard = document.getElementById('infoCard');
      if (infoCard.style.display === 'none' || infoCard.style.display === '') {
        infoCard.style.display = 'block'; showOverlay();
      } else { infoCard.style.display = 'none'; hideOverlay(); }
    });
    document.getElementById('infoCard').addEventListener('click', () => { document.getElementById('infoCard').style.display = 'none'; hideOverlay(); });
    document.getElementById('myCoinTab').addEventListener('click', () => {
      const form = document.getElementById('myCoinForm');
      if (form.style.display === 'none' || form.style.display === '') { form.style.display = 'block'; showOverlay(); }
      else { form.style.display = 'none'; hideOverlay(); }
    });
    document.getElementById('closeMyCoinForm').addEventListener('click', () => { document.getElementById('myCoinForm').style.display = 'none'; hideOverlay(); });
    document.getElementById('profileTab').addEventListener('click', () => {
      const profileCard = document.getElementById('profileCard');
      if (profileCard.style.display === 'none' || profileCard.style.display === '') { profileCard.style.display = 'block'; showOverlay(); }
      else { profileCard.style.display = 'none'; hideOverlay(); }
    });
    document.getElementById('profileCard').addEventListener('click', () => { document.getElementById('profileCard').style.display = 'none'; hideOverlay(); });
    document.getElementById('walletTab').addEventListener('click', () => {
      const walletCard = document.getElementById('walletCard');
      if (walletCard.style.display === 'none' || walletCard.style.display === '') {
        walletCard.style.display = 'block'; showOverlay(); updateWalletDisplay();
      } else { walletCard.style.display = 'none'; hideOverlay(); }
    });
    document.getElementById('walletCard').addEventListener('click', () => { document.getElementById('walletCard').style.display = 'none'; hideOverlay(); });
    // ØªØºÛŒÛŒØ± Ù†Ø§Ù… Ù…ØªØºÛŒØ± Ø¨Ø±Ø§ÛŒ Ø±ÙˆØ´Ù† Ø¨ÙˆØ¯Ù† Ú©Ø§Ø±Ú©Ø±Ø¯
    const upgradeCardElement = document.getElementById('upgradeCard');
    upgradeCardElement.addEventListener('click', (event) => {
        // Ú†Ú© Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… Ú©Ù‡ Ø¢ÛŒØ§ Ú©Ù„ÛŒÚ© Ø±ÙˆÛŒ ÛŒÚ©ÛŒ Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ø±ÛŒØ¯ ÛŒØ§ ÙØ±Ø²Ù†Ø¯Ø§Ù† Ø¢Ù† Ø¨ÙˆØ¯Ù‡ Ø§Ø³Øª
        const clickedUpgradeButton = event.target.closest('.upgrade-btn');
        if (clickedUpgradeButton) {
            // Ø§Ú¯Ø± Ø¯Ú©Ù…Ù‡â€ŒØ§ÛŒ Ù¾ÛŒØ¯Ø§ Ø´Ø¯ØŒ Ø§Ù…Ø§ ØºÛŒØ± ÙØ¹Ø§Ù„ Ø¨Ø§Ø´Ø¯ØŒ Ø§Ø¬Ø§Ø²Ù‡ Ø¨Ø³ØªÙ† Ú©Ø§Ø±Øª Ø±Ø§ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒÙ…
            if (clickedUpgradeButton.disabled) {
                 // Ø§Ú¯Ø± Ø¯Ú©Ù…Ù‡ ØºÛŒØ± ÙØ¹Ø§Ù„ Ø¨ÙˆØ¯ØŒ Ú©Ø§Ø±Øª Ø¨Ø³ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
                 upgradeCardElement.style.display = 'none';
                 hideOverlay();
            }
            // Ø§Ú¯Ø± Ø¯Ú©Ù…Ù‡ ÙØ¹Ø§Ù„ Ø¨ÙˆØ¯ØŒ Ø§Ø² Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù† Ú©Ø§Ø±Øª Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
            // (ØªØ§Ø¨Ø¹ onclick Ø¯Ú©Ù…Ù‡ Ø§Ø¬Ø§Ø²Ù‡ Ø§Ø¬Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ù…ÛŒâ€ŒÚ©Ù†Ø¯)
            return;
        }
        // Ø§Ú¯Ø± Ú©Ù„ÛŒÚ© Ø±ÙˆÛŒ Ú†ÛŒØ² Ø¯ÛŒÚ¯Ø±ÛŒ (Ù…Ø«Ù„ ÙØ¶Ø§ÛŒ Ø®Ø§Ù„ÛŒ Ú©Ø§Ø±Øª ÛŒØ§ Ù…ØªÙ† ØªÙˆØ¶ÛŒØ­Ø§Øª) Ø¨ÙˆØ¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ Ú©Ø§Ø±Øª Ø±Ø§ Ù…ÛŒâ€ŒØ¨Ù†Ø¯ÛŒÙ…
        upgradeCardElement.style.display = 'none';
        hideOverlay();
    });
    document.getElementById('historyTab').addEventListener('click', () => {
      const historyCard = document.getElementById('historyCard');
      if (historyCard.style.display === 'none' || historyCard.style.display === '') {
        historyCard.style.display = 'block'; showOverlay(); renderHistory();
      } else { historyCard.style.display = 'none'; hideOverlay(); }
    });
    document.getElementById('historyCard').addEventListener('click', () => { document.getElementById('historyCard').style.display = 'none'; hideOverlay(); });
    // Overlay global click
    document.addEventListener('click', (e) => {
      if (e.target.id === 'overlay') {
        hideOverlay();
        ['infoCard','myCoinForm','secretForm','profileCard','walletCard','upgradeCard','historyCard'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = 'none';
        });
      }
    });
    // Controls
    document.querySelectorAll('.timeframe-tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const frame = this.getAttribute('data-frame');
        if (!frame) return;
        setTimeFrame(frame);
        document.querySelectorAll('.timeframe-tab').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
      });
    });
    document.getElementById('coinNameTab').addEventListener('click', () => switchToCoin('bitcoin'));
    document.getElementById('coinEthereumTab').addEventListener('click', () => switchToCoin('ethereum'));
    document.getElementById('coinBinanceTab').addEventListener('click', () => switchToCoin('binance'));
    document.getElementById('personalCoinTab').addEventListener('click', () => { if (personalCoinKey && coins[personalCoinKey]) switchToCoin(personalCoinKey); });
    document.getElementById('secretTab').addEventListener('click', function() {
      const form = document.getElementById('secretForm');
      form.style.display = (form.style.display === 'none' || form.style.display === '') ? 'block' : 'none';
    });
    document.getElementById('applySecret').addEventListener('click', function() {
      const code = document.getElementById('secretCode').value.trim();
      const amount = parseFloat(document.getElementById('secretAmount').value);
      if (code.toLowerCase() === 'Ù…Ù‡Ø±Ø§Ù†' && !isNaN(amount) && amount > 0) {
        balance += amount; updateDisplay();
        alert(`ØªØ¨Ø±ÛŒÚ©! ${amount} Ø¯Ù„Ø§Ø± Ø¨Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯ ğŸ’°`);
        document.getElementById('secretCode').value = '';
        document.getElementById('secretAmount').value = '';
        document.getElementById('secretForm').style.display = 'none';
      } else { alert('Ú©Ø¯ ÛŒØ§ Ù…Ù‚Ø¯Ø§Ø± ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ Ø§Ø´ØªØ¨Ø§Ù‡Ù‡ ğŸ˜•'); }
    });
    document.getElementById('orderType').addEventListener('change', function() {
      const limitInput = document.getElementById('limitPriceInput');
      limitInput.style.display = (this.value === 'limit') ? 'block' : 'none';
    });
    document.getElementById("buyBtn").addEventListener("click", function() {
      const coin = getCurrentCoinData();
      const orderType = document.getElementById("orderType").value;
      const percent = parseInt(document.getElementById("tradePercent").value);
      const amountToSpend = balance * (percent / 100);
      if (orderType === 'market') {
        const totalBoughtByUser = coin.coinAmount + (wallet[currentCoin]?.amount || 0);
        if (balance <= 0 || totalBoughtByUser >= coin.totalSupply) {
          if (totalBoughtByUser >= coin.totalSupply) alert("âŒ ØªÙ…Ø§Ù… Ø³Ú©Ù‡â€ŒÙ‡Ø§ ØªÙˆØ³Ø· Ø´Ù…Ø§ (Ø¯Ø± ØµØ±Ø§ÙÛŒ ÛŒØ§ Ú©ÛŒÙ Ù¾ÙˆÙ„) Ø®Ø±ÛŒØ¯Ø§Ø±ÛŒ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯! Ø¯ÛŒÚ¯Ø± Ø§Ù…Ú©Ø§Ù† Ø®Ø±ÛŒØ¯ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.");
          return;
        }
        const coinsBought = amountToSpend / coin.livePrice;
        const maxCoinsAllowedBySupply = coin.totalSupply - (coin.coinAmount + (wallet[currentCoin]?.amount || 0));
        if (coinsBought > maxCoinsAllowedBySupply) {
          if (maxCoinsAllowedBySupply <= 0) { alert("âŒ ØªÙ…Ø§Ù… Ø³Ú©Ù‡â€ŒÙ‡Ø§ ØªÙˆØ³Ø· Ø´Ù…Ø§ Ø®Ø±ÛŒØ¯Ø§Ø±ÛŒ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯!"); return; }
          const newAmount = maxCoinsAllowedBySupply * coin.livePrice;
          balance -= newAmount;
          coin.coinAmount += maxCoinsAllowedBySupply;
          coin.avgPrice = coin.coinAmount > 0
            ? ((coin.avgPrice * (coin.coinAmount - maxCoinsAllowedBySupply)) + (coin.livePrice * maxCoinsAllowedBySupply)) / coin.coinAmount
            : coin.livePrice;
          alert(`âš ï¸ ÙÙ‚Ø· ${maxCoinsAllowedBySupply.toFixed(4)} Ø³Ú©Ù‡ Ø¯ÛŒÚ¯Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ø®Ø±ÛŒØ¯. Ø®Ø±ÛŒØ¯ Ø¨Ù‡ Ø§ÛŒÙ† Ù…Ù‚Ø¯Ø§Ø± Ù…Ø­Ø¯ÙˆØ¯ Ø´Ø¯.`);
        } else {
          balance -= amountToSpend;
          coin.coinAmount += coinsBought;
          coin.avgPrice = coin.coinAmount > 0
            ? ((coin.avgPrice * (coin.coinAmount - coinsBought)) + (coin.livePrice * coinsBought)) / coin.coinAmount
            : coin.livePrice;
        }
        const stopLossPercent = parseInt(document.getElementById("stopLossPercent").value);
        coin.stopLossPrice = coin.avgPrice * (1 - stopLossPercent / 100);
        const onePercentSupply = coin.totalSupply * 0.01;
        if (!isPriceFrozen && coinsBought >= onePercentSupply) {
          const newPrice = coin.livePrice * 1.03;
          applyPriceChangeForCoin(currentCoin, newPrice);
          if (currentCoin === 'bitcoin') coins.bitcoin.livePrice = newPrice;
          alert(`ğŸ”¥ Ù¾Ø§Ù…Ù¾! Ø®Ø±ÛŒØ¯ Ø¨Ø²Ø±Ú¯ (${(coinsBought / coin.totalSupply * 100).toFixed(2)}%) Ø¨Ø§Ø¹Ø« Ø±Ø´Ø¯  3% Ù‚ÛŒÙ…Øª Ø´Ø¯ !`);
        } else {
          updateDisplay();
        }
      } else if (orderType === 'limit') {
        const limitPrice = parseFloat(document.getElementById("limitPrice").value);
        if (isNaN(limitPrice) || limitPrice <= 0) { alert("Ù„Ø·ÙØ§Ù‹ Ù‚ÛŒÙ…Øª Ù„ÛŒÙ…ÛŒØª Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); return; }
        limitOrders.push({ type: 'buy', price: limitPrice, amount: amountToSpend, coinKey: currentCoin });
        alert(`âœ… Ø§ÙˆØ±Ø¯Ø± Ø®Ø±ÛŒØ¯ Ù„ÛŒÙ…ÛŒØª Ø¨Ù‡ Ù‚ÛŒÙ…Øª $${limitPrice} Ø«Ø¨Øª Ø´Ø¯.`);
      }
      saveGame();
    });
    document.getElementById("sellBtn").addEventListener("click", function() {
      const coin = getCurrentCoinData();
      const orderType = document.getElementById("orderType").value;
      const percent = parseInt(document.getElementById("tradePercent").value);
      const coinsToSell = coin.coinAmount * (percent / 100);
      if (orderType === 'market') {
        if (coin.coinAmount <= 0) return;
        const onePercentSupply = coin.totalSupply * 0.01;
        const sellValue = coinsToSell * coin.livePrice;
        const realizedPnl = (coin.livePrice - coin.avgPrice) * coinsToSell;
        balance += sellValue;
        coin.coinAmount -= coinsToSell;
        if (coin.coinAmount <= 0) { coin.coinAmount = 0; coin.avgPrice = 0; }
        addTradeHistoryRecord(currentCoin, realizedPnl);
        if (!isPriceFrozen && coinsToSell >= onePercentSupply) {
          const newPrice = coin.livePrice * 0.98;
          applyPriceChangeForCoin(currentCoin, newPrice);
          if (currentCoin === 'bitcoin') coins.bitcoin.livePrice = newPrice;
          alert(`ğŸ“‰ Ø¯Ø§Ù…Ù¾! ÙØ±ÙˆØ´ Ø¨Ø²Ø±Ú¯ (${(coinsToSell / coin.totalSupply * 100).toFixed(2)}%) Ø¨Ø§Ø¹Ø« Ø³Ù‚ÙˆØ· 3% Ù‚ÛŒÙ…Øª Ø´Ø¯!`);
        } else {
          updateDisplay();
        }
      } else if (orderType === 'limit') {
        const limitPrice = parseFloat(document.getElementById("limitPrice").value);
        if (isNaN(limitPrice) || limitPrice <= 0) { alert("Ù„Ø·ÙØ§Ù‹ Ù‚ÛŒÙ…Øª Ù„ÛŒÙ…ÛŒØª Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); return; }
        const amountToSell = coinsToSell * coin.livePrice;
        limitOrders.push({ type: 'sell', price: limitPrice, amount: amountToSell, coinKey: currentCoin });
        alert(`âœ… Ø§ÙˆØ±Ø¯Ø± ÙØ±ÙˆØ´ Ù„ÛŒÙ…ÛŒØª Ø¨Ù‡ Ù‚ÛŒÙ…Øª $${limitPrice} Ø«Ø¨Øª Ø´Ø¯.`);
      }
      saveGame();
    });
    document.getElementById('freezePriceBtn').addEventListener('click', function() {
      isPriceFrozen = !isPriceFrozen;
      this.innerText = isPriceFrozen ? 'â–¶ï¸' : 'â¸ï¸';
      this.title = isPriceFrozen ? 'Ù‚ÛŒÙ…Øª ÙØ±ÛŒØ² Ø´Ø¯Ù‡ â€” Ù¾Ø§Ù…Ù¾/Ø¯Ø§Ù…Ù¾ ØºÛŒØ±ÙØ¹Ø§Ù„' : 'ÙØ±ÛŒØ² Ù‚ÛŒÙ…Øª (Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù¾Ø§Ù…Ù¾/Ø¯Ø§Ù…Ù¾)';
      saveGame();
    });
    document.getElementById('createCoinBtn').addEventListener('click', createMyCoin);
    document.getElementById('transferToWalletBtn').addEventListener('click', transferToWallet);
    document.getElementById('transferFromWalletBtn').addEventListener('click', transferFromWallet);
    document.getElementById("resetBtn").addEventListener("click", () => {
      if (!confirm("Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø¨Ø§Ø²ÛŒ Ø±Ø§ Ø±ÛŒØ³Øª Ú©Ù†ÛŒØ¯ØŸ Ø§ÛŒÙ† Ø¹Ù…Ù„ Ù‚Ø§Ø¨Ù„ Ø¨Ø§Ø²Ú¯Ø´Øª Ù†ÛŒØ³Øª.")) return;
      localStorage.removeItem("nasrTradingGameSave");
      balance = 1000;
      virtualDay = 1; virtualMonth = 1; virtualYear = 2022;
      moveCounter = 0; isPriceFrozen = false; liquidityPool = 100000;
      traderName = "Ù¾Ù„ÛŒØ±"; initialBalance = 1000;
      limitOrders = []; currentBitcoinDominance = 40; lastUpdatedMonth = virtualMonth;
      coins = {
        bitcoin: {
          name: "Ø¨ÛŒØªÚ©ÙˆÛŒÙ†", totalSupply: 21000000, livePrice: 16000,
          coinAmount: 0, avgPrice: 0, stopLossPrice: 0, price24hAgo: 16000, cycleStep: 0,
          timeframes: {
            live:  createInitialTimeframeData(16000),
            hour1: createInitialTimeframeData(16000),
            hour4: createInitialTimeframeData(16000),
            day1:  createInitialTimeframeData(16000),
            week1: createInitialTimeframeData(16000)
          }
        },
        ethereum: {
          name: "Ø§ØªØ±ÛŒÙˆÙ…", totalSupply: 120000000, livePrice: 1100,
          coinAmount: 0, avgPrice: 0, stopLossPrice: 0, price24hAgo: 1100, cycleStep: 0,
          timeframes: {
            live:  createInitialTimeframeData(1100),
            hour1: createInitialTimeframeData(1100),
            hour4: createInitialTimeframeData(1100),
            day1:  createInitialTimeframeData(1100),
            week1: createInitialTimeframeData(1100)
          }
        },
        binance: {
          name: "Ø¨Ø§ÛŒÙ†Ù†Ø³ Ú©ÙˆÛŒÙ†", totalSupply: 140000000, livePrice: 200,
          coinAmount: 0, avgPrice: 0, stopLossPrice: 0, price24hAgo: 200, cycleStep: 0,
          timeframes: {
            live:  createInitialTimeframeData(200),
            hour1: createInitialTimeframeData(200),
            hour4: createInitialTimeframeData(200),
            day1:  createInitialTimeframeData(200),
            week1: createInitialTimeframeData(200)
          }
        }
      };
      currentCoin = 'bitcoin';
      personalCoinKey = null;
      wallet = {};
      tradeHistory = [];
      renderHistory();
      updateCoinPercentages();
      updateDisplay();
      updateCalendarDisplay(virtualDay, virtualMonth, virtualYear);
      document.getElementById("coinNameDisplay").innerText = "Ø¨ÛŒØªÚ©ÙˆÛŒÙ† â‚¿";
      document.getElementById("dominanceDisplay").style.display = 'block';
      document.getElementById("bitcoinDominanceValue").innerText = currentBitcoinDominance.toFixed(2) + "%";
      document.getElementById("totalSupplyDisplay").innerText = formatTotalSupply(21000000);
      document.getElementById("coinNameTab").innerText = "Ø¨ÛŒØªÚ©ÙˆÛŒÙ† â‚¿";
      document.getElementById("coinEthereumTab").innerText = "Ø§ØªØ±ÛŒÙˆÙ… Î";
      document.getElementById("coinBinanceTab").innerText = "Ø¨Ø§ÛŒÙ†Ù†Ø³ Ú©ÙˆÛŒÙ† â›“ï¸";
      document.getElementById("personalCoinTab").style.display = "none";
      const initialMarketCapInMillions = (16000 * 21000000) / 1_000_000;
      document.getElementById("marketCap").innerText = formatMarketCap(initialMarketCapInMillions);
      updatePriceChart();
      rsiChart.data.labels = [1];
      rsiChart.data.datasets[0].data = coins.bitcoin.timeframes.live.rsiData;
      rsiChart.update();
      document.getElementById('freezePriceBtn').innerText = 'â¸ï¸';
      document.getElementById('freezePriceBtn').title = 'ÙØ±ÛŒØ² Ù‚ÛŒÙ…Øª (Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù¾Ø§Ù…Ù¾/Ø¯Ø§Ù…Ù¾)';
      document.querySelectorAll('.coin-tab').forEach(tab => tab.classList.remove('active'));
      document.getElementById('coinNameTab').classList.add('active');
      updateUpgradeTabStatus();
      updateUpgradeButtons();
      alert("Ø¨Ø§Ø²ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±ÛŒØ³Øª Ø´Ø¯.");
    });
    document.getElementById('burnBalanceBtn').addEventListener('click', function burnBalanceTo1000() {
      if (balance <= 1000) { alert("Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø´Ù…Ø§ Ú©Ù…ØªØ± ÛŒØ§ Ù…Ø³Ø§ÙˆÛŒ 1000 Ø¯Ù„Ø§Ø± Ø§Ø³Øª. Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ Ø³ÙˆØ²Ø§Ù†Ø¯Ù† Ù†ÛŒØ³Øª."); return; }
      balance = 1000; updateDisplay(); saveGame();
      alert("Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø´Ù…Ø§ Ø¨Ù‡ 1000 Ø¯Ù„Ø§Ø± Ú©Ø§Ù‡Ø´ ÛŒØ§ÙØª! ğŸ’¸ğŸ”¥");
    });
    /***********************
     * RSI Chart            *
     ***********************/
    const rsiCtx = document.getElementById('rsiChart').getContext('2d');
    const rsiChart = new Chart(rsiCtx, {
      type: 'line',
      data: { labels: [], datasets: [{ label: 'RSI', data: [], borderColor: 'purple', borderWidth: 2, fill: false, tension: 0.1 }] },
      options: {
        responsive: true, maintainAspectRatio: false, animation: false,
        plugins: { annotation: { annotations: {
          line70: { type: 'line', yMin: 70, yMax: 70, borderColor: 'red', borderWidth: 1, label: { content: '70', enabled: true, position: 'start' } },
          line30: { type: 'line', yMin: 30, yMax: 30, borderColor: 'green', borderWidth: 1, label: { content: '30', enabled: true, position: 'start' } }
        } } },
        scales: { y: { min: 20, max: 80, ticks: { stepSize: 30 } } }
      }
    });
    /***********************
     * Boot                 *
     ***********************/
    window.onload = () => {
      loadGame();
      initPriceChart();
      const coin = getCurrentCoinData();
      updateDisplay();
      updateCalendarDisplay(virtualDay, virtualMonth, virtualYear);
      updateCoinPercentages();
      document.getElementById("coinNameDisplay").innerText = coin.name;
      if (currentCoin === 'bitcoin') {
        document.getElementById("dominanceDisplay").style.display = 'block';
        document.getElementById("bitcoinDominanceValue").innerText = currentBitcoinDominance.toFixed(2) + "%";
      } else {
        document.getElementById("dominanceDisplay").style.display = 'none';
      }
      document.getElementById("totalSupplyDisplay").innerText = formatTotalSupply(coin.totalSupply);
      document.getElementById("coinNameTab").innerText = "Ø¨ÛŒØªÚ©ÙˆÛŒÙ† â‚¿";
      document.getElementById("coinEthereumTab").innerText = "Ø§ØªØ±ÛŒÙˆÙ… Î";
      document.getElementById("coinBinanceTab").innerText = "Ø¨Ø§ÛŒÙ†Ù†Ø³ Ú©ÙˆÛŒÙ† â›“ï¸";
      document.getElementById("traderName").innerText = traderName;
      const initialMarketCapInMillions = (coin.livePrice * coin.totalSupply) / 1_000_000;
      document.getElementById("marketCap").innerText = formatMarketCap(initialMarketCapInMillions);
      setTimeFrame("live");
    };
  </script>
</body>
</html>
